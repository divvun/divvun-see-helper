#!/bin/bash

# Ensure UTF-8 handling
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# Extend PATH to include common binary locations
# This is critical when running from macOS Services which have minimal PATH
export PATH="$HOME/.cargo/bin:/usr/local/bin:/opt/homebrew/bin:$PATH"

# Check if logging is enabled via config file
ENABLE_LOGGING=false
if [ -f "$HOME/.divvun-see-helper-config" ]; then
    source "$HOME/.divvun-see-helper-config"
fi

# Helper function for logging
log() {
    if [ "$ENABLE_LOGGING" = "true" ]; then
        LOG_FILE="$HOME/divvun-see-helper-debug.log"
        echo "$@" >> "$LOG_FILE"
    fi
}

log "=== Divvun SEE Helper Started at $(date) ==="
log "Args: $@"
log "LANG: $LANG"

# Check if we got command line arguments (for direct invocation)
if [ $# -gt 0 ]; then
    OPERATION="$1"
    LANGCODE="$2"
    GTLANGS="$3"
    DOCNAME="$4"
    
    log "Operation from args: $OPERATION"
    log "LANG: $LANGCODE"
    log "GTLANGS: $GTLANGS"
    log "DOCNAME: $DOCNAME"
    
    # Read input words from clipboard
    INPUT_WORDS=$(pbpaste)
    log "INPUT_WORDS from clipboard: ${INPUT_WORDS:0:100}..."
else
    # Read JSON from clipboard
    INPUT_JSON=$(pbpaste)
    log "Clipboard content (first 200 chars): ${INPUT_JSON:0:200}"
    
    # Parse JSON using python - check for base64-encoded input first
    if [ "$ENABLE_LOGGING" = "true" ]; then
        OPERATION=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('operation', ''))" 2>> "$LOG_FILE")
        LANGCODE=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('lang', ''))" 2>> "$LOG_FILE")
        GTLANGS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('gtlangs', ''))" 2>> "$LOG_FILE")
        DOCNAME=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('docname', ''))" 2>> "$LOG_FILE")
    else
        OPERATION=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('operation', ''))" 2>/dev/null)
        LANGCODE=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('lang', ''))" 2>/dev/null)
        GTLANGS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('gtlangs', ''))" 2>/dev/null)
        DOCNAME=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('docname', ''))" 2>/dev/null)
    fi
    
    # Check if input is base64-encoded
    if [ "$ENABLE_LOGGING" = "true" ]; then
        if echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); sys.exit(0 if 'input_words_b64' in data else 1)" 2>> "$LOG_FILE"; then
            log "Input is base64-encoded"
            INPUT_WORDS=$(LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 echo "$INPUT_JSON" | python3 -c "import sys, json, base64; data=json.load(sys.stdin); print(base64.b64decode(data['input_words_b64']).decode('utf-8'))" 2>> "$LOG_FILE")
        else
            INPUT_WORDS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('input_words', ''))" 2>> "$LOG_FILE")
        fi
    else
        if echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); sys.exit(0 if 'input_words_b64' in data else 1)" 2>/dev/null; then
            INPUT_WORDS=$(LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8 echo "$INPUT_JSON" | python3 -c "import sys, json, base64; data=json.load(sys.stdin); print(base64.b64decode(data['input_words_b64']).decode('utf-8'))" 2>/dev/null)
        else
            INPUT_WORDS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('input_words', ''))" 2>/dev/null)
        fi
    fi
    
    log "Operation: $OPERATION"
    log "LANG: $LANGCODE"
    log "GTLANGS: $GTLANGS"
    log "DOCNAME: $DOCNAME"
    log "INPUT_WORDS (first 100 chars): ${INPUT_WORDS:0:100}..."
fi

if [ "$OPERATION" = "analyze_missing" ]; then
    # New operation: run missing.py from giella-core
    
    # Find missing.py - try multiple locations
    MISSING_PY=""
    
    # Try GTLANGS/giella-core first
    if [ -f "$GTLANGS/giella-core/scripts/missing.py" ]; then
        MISSING_PY="$GTLANGS/giella-core/scripts/missing.py"
        log "Found missing.py at: $MISSING_PY"
    # Try config file
    elif [ -f "$HOME/.divvun-see-helper-config" ]; then
        source "$HOME/.divvun-see-helper-config"
        if [ -n "$GTCORE" ] && [ -f "$GTCORE/scripts/missing.py" ]; then
            MISSING_PY="$GTCORE/scripts/missing.py"
            log "Found missing.py via config at: $MISSING_PY"
        fi
    fi
    
    # Try standard locations
    if [ -z "$MISSING_PY" ]; then
        for TRYPATH in "$HOME/langtech/gut/giellalt/giella-core" "$HOME/langtech/giellalt/giella-core"; do
            if [ -f "$TRYPATH/scripts/missing.py" ]; then
                MISSING_PY="$TRYPATH/scripts/missing.py"
                log "Found missing.py at standard location: $MISSING_PY"
                break
            fi
        done
    fi
    
    if [ -z "$MISSING_PY" ]; then
        log "ERROR: Could not find missing.py"
        echo '{"status": "error", "message": "Could not find missing.py. Try creating ~/.divvun-see-helper-config with GTCORE=/path/to/giella-core"}' | pbcopy
        exit 1
    fi
    
    # Set up environment and run missing.py
    export PATH=/opt/homebrew/bin:/usr/local/bin:$PATH
    export GTLANGS="$GTLANGS"
    export LC_ALL=en_US.UTF-8
    
    log "Running: echo \$INPUT_WORDS | python3 $MISSING_PY -l $LANGCODE -c $DOCNAME"
    OUTPUT=$(printf "%s" "$INPUT_WORDS" | python3 "$MISSING_PY" -l "$LANGCODE" -c "$DOCNAME" 2>&1)
    EXIT_CODE=$?
    log "missing.py exit code: $EXIT_CODE"
    log "Output length: ${#OUTPUT}"
    
    if [ $EXIT_CODE -eq 0 ]; then
        # Success - return output directly
        printf "%s" "$OUTPUT" | python3 -c "import json, sys; print(json.dumps({'status': 'success', 'output': sys.stdin.read()}))"  | pbcopy
        log "Success! Result written to clipboard"
    else
        log "ERROR: missing.py failed"
        log "Error output: $OUTPUT"
        python3 -c "import json; print(json.dumps({'status': 'error', 'message': 'missing.py failed', 'details': '''$OUTPUT'''}))" | pbcopy
    fi
    
elif [ "$OPERATION" = "hfst_lookup" ]; then
    # Legacy operation: direct hfst-lookup (keep for compatibility)
    if [ "$ENABLE_LOGGING" = "true" ]; then
        FST_FILE=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('fst_file', ''))" 2>> "$LOG_FILE")
        INPUT_WORDS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('input_words', ''))" 2>> "$LOG_FILE")
    else
        FST_FILE=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('fst_file', ''))" 2>/dev/null)
        INPUT_WORDS=$(echo "$INPUT_JSON" | python3 -c "import sys, json; data=json.load(sys.stdin); print(data.get('input_words', ''))" 2>/dev/null)
    fi
    
    log "FST_FILE: $FST_FILE"
    log "INPUT_WORDS: $INPUT_WORDS"
    
    if [ -z "$FST_FILE" ] || [ -z "$INPUT_WORDS" ]; then
        log "ERROR: Missing FST file or input words"
        echo '{"status": "error", "message": "Invalid input"}' | pbcopy
        exit 1
    fi
    
    if [ ! -f "$FST_FILE" ]; then
        log "ERROR: FST file not found: $FST_FILE"
        echo '{"status": "error", "message": "FST file not found"}' | pbcopy
        exit 1
    fi
    
    # Run hfst-lookup
    export PATH=/opt/homebrew/bin:/usr/local/bin:$PATH
    log "Running hfst-lookup..."
    if [ "$ENABLE_LOGGING" = "true" ]; then
        OUTPUT=$(printf "%s" "$INPUT_WORDS" | hfst-lookup "$FST_FILE" 2>> "$LOG_FILE")
    else
        OUTPUT=$(printf "%s" "$INPUT_WORDS" | hfst-lookup "$FST_FILE" 2>/dev/null)
    fi
    EXIT_CODE=$?
    log "hfst-lookup exit code: $EXIT_CODE"
    
    if [ $EXIT_CODE -eq 0 ]; then
        printf "%s" "$OUTPUT" | python3 -c "import json, sys; print(json.dumps({'status': 'success', 'output': sys.stdin.read()}))"  | pbcopy
        log "Success! Result written to clipboard"
    else
        log "ERROR: hfst-lookup failed"
        echo '{"status": "error", "message": "hfst-lookup failed"}' | pbcopy
    fi

elif [ "$OPERATION" = "divvun_analyze" ]; then
    # New operation: analyze text with divvun-runtime and .drb file
    
    log "Operation: divvun_analyze"
    log "Language: $LANGCODE"
    log "GTLANGS: $GTLANGS"
    
    # Check if divvun-runtime is available
    if ! command -v divvun-runtime &> /dev/null; then
        log "ERROR: divvun-runtime not found in PATH"
        echo '{"status": "error", "message": "divvun-runtime not found. Install it with: brew install divvun/divvun/divvun-runtime"}' | pbcopy
        exit 1
    fi
    
    # Find the newest .drb file for the language
    # GTLANGS should point to the giellalt root (e.g., /path/to/giellalt)
    # We append lang-${LANGCODE} to get the language-specific directory
    # The analyser file can be named either ${LANGCODE}.drb or bundle.drb
    DRB_FILE=""
    
    # Construct path to language directory
    LANG_DIR="${GTLANGS}/lang-${LANGCODE}"
    
    log "Searching for analyser .drb in ${LANG_DIR}/*/tools/analysers/..."
    
    # Search for analyser in tools/analysers/ subdirectories
    # First try language-specific name (${LANGCODE}.drb), then fallback to bundle.drb
    if [ -d "$LANG_DIR" ]; then
        # Try ${LANGCODE}.drb first
        FOUND_FILES=$(find "$LANG_DIR" -maxdepth 5 -type f -path "*/tools/analysers/${LANGCODE}.drb" 2>/dev/null)
        
        # If not found, try bundle.drb  
        if [ -z "$FOUND_FILES" ]; then
            FOUND_FILES=$(find "$LANG_DIR" -maxdepth 5 -type f -path "*/tools/analysers/bundle.drb" 2>/dev/null)
        fi
        
        if [ -n "$FOUND_FILES" ]; then
            # Get the newest file by modification time
            while IFS= read -r file; do
                if [ -z "$DRB_FILE" ] || [ "$file" -nt "$DRB_FILE" ]; then
                    DRB_FILE="$file"
                fi
            done <<< "$FOUND_FILES"
        fi
    fi
    
    if [ -z "$DRB_FILE" ]; then
        log "ERROR: Could not find ${LANGCODE}.drb file"
        echo '{"status": "error", "message": "Could not find .drb file for language '"$LANGCODE"'. Build the analyser first."}' | pbcopy
        exit 1
    fi
    
    log "Found .drb file: $DRB_FILE"
    
    # Run divvun-runtime with the .drb file
    # Disable ANSI color codes with NO_COLOR to get clean output
    export PATH=/opt/homebrew/bin:/usr/local/bin:$PATH
    export NO_COLOR=1
    log "Running: divvun-runtime run -p $DRB_FILE"
    
    if [ "$ENABLE_LOGGING" = "true" ]; then
        OUTPUT=$(printf "%s" "$INPUT_WORDS" | divvun-runtime run -p "$DRB_FILE" 2>> "$LOG_FILE")
    else
        OUTPUT=$(printf "%s" "$INPUT_WORDS" | divvun-runtime run -p "$DRB_FILE" 2>/dev/null)
    fi
    EXIT_CODE=$?
    
    log "divvun-runtime exit code: $EXIT_CODE"
    log "Output length: ${#OUTPUT}"
    
    if [ $EXIT_CODE -eq 0 ]; then
        # Success - return output
        printf "%s" "$OUTPUT" | python3 -c "import json, sys; print(json.dumps({'status': 'success', 'output': sys.stdin.read()}))" | pbcopy
        log "Success! Result written to clipboard"
    else
        log "ERROR: divvun-runtime failed"
        log "Error output: $OUTPUT"
        python3 -c "import json; print(json.dumps({'status': 'error', 'message': 'divvun-runtime failed', 'details': '''$OUTPUT'''}))" | pbcopy
    fi

else
    log "ERROR: Unknown operation: $OPERATION"
    echo '{"status": "error", "message": "Unknown operation"}' | pbcopy
    exit 1
fi

log "=== Helper Finished ==="
log ""
